{"meta":{"title":"夏之颜博客","subtitle":"努力的意义是不断的优化自己；     努力的意义是当下的一点一滴；     努力是为了不让热爱的世界拱手相让于人。","description":"天行健，君子以自强不息","author":"夏之颜","url":"http://yanhq.top"},"pages":[{"title":"归档","date":"2019-11-02T03:18:42.000Z","updated":"2019-11-03T14:49:08.221Z","comments":true,"path":"archives/index.html","permalink":"http://yanhq.top/archives/index.html","excerpt":"","text":""},{"title":"关于","date":"2019-11-02T03:19:51.000Z","updated":"2019-11-03T14:49:45.416Z","comments":true,"path":"about/index.html","permalink":"http://yanhq.top/about/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-11-02T03:19:28.000Z","updated":"2019-11-03T14:45:27.450Z","comments":true,"path":"tags/index.html","permalink":"http://yanhq.top/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-11-02T03:17:54.000Z","updated":"2019-11-02T03:20:37.960Z","comments":false,"path":"categories/index.html","permalink":"http://yanhq.top/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Java设计模式之-单例模式","slug":"Java设计模式之-单例模式","date":"2019-11-12T09:17:32.307Z","updated":"2019-11-12T09:20:49.454Z","comments":true,"path":"2019/11/12/Java设计模式之-单例模式/","link":"","permalink":"http://yanhq.top/2019/11/12/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","excerpt":"概念 保证一个类仅有一个实例，并提供一个全局访问方法。构造方法私有化，类内部产生实例化对象并提供static方法获取实例化对象，不管外部怎么操作，都只有一个实例化对象。","text":"概念 保证一个类仅有一个实例，并提供一个全局访问方法。构造方法私有化，类内部产生实例化对象并提供static方法获取实例化对象，不管外部怎么操作，都只有一个实例化对象。 通俗点讲单例模式就是：类的构造函数弄成private ，即不想让别人用new 方法来创建多个对象，可以在类里面先生成一个对象，然后写一个public static方法把这个对象return出去。 饿汉式在系统加载类的时候会自动提供实例化对象。常见代码如下： 1234567891011121314151617181920212223242526/** * 单例模式-饿汉式 */public class Singleton &#123; //私有静态方法，防止被引用。为了使得类内部不能再次实例化，使用final private static final Singleton instance=new Singleton(); //构造方法私有化，防止被实例化 private Singleton()&#123; &#125; public static Singleton getInstance()&#123; return instance; &#125; public void print()&#123; System.out.println(\"Hello world\"); &#125;&#125;/*** 调用测试*/public class test &#123; public static void main(String[] args) &#123; Singleton instance=null;//声明对象 instance=Singleton.getInstance(); instance.print(); &#125;&#125; 注意：为什么使用static？在static方法内部不能调用非静态方法，反过来是可以的。而且可以在没有创建任何对象的前提下，仅仅通过类本身来调用static方法。一句话：方便在没有创建对象的情况下来进行调用。 ##懒汉式在系统加载类的时候不会自动提供实例化对象，而是在第一次使用的时候，进行实例化对象处理。常见代码如下： 12345678910111213141516171819/** * 单例模式-懒汉式 */public class Singleton2 &#123; //私有静态方法，防止被引用，此处赋值为null，目的是实现延迟加载 private static Singleton instance=null; //构造方法私有化，防止被实例化 private Singleton()&#123; &#125; public static Singleton getInstance()&#123; if(instance==null)&#123;//第一次使用时才实例化对象 instance=new Singleton(); &#125; return instance; &#125; public void print()&#123; System.out.println(\"Hello world\"); &#125;&#125; 为什么需要单例模式？：如果一个类不需要产生重复对象，例如：一个类启动只需要一个类负责保存程序加载的数据信息。保证不管谁访问，都只产生一个对象。##反射与懒汉式单例模式如果在多线程情况下，如上懒汉式单例模式代码就会造成不只产生一个实例化对象，这时候单例模式就不起作用了。这个问题的原因是多线程情况下，以下判断不同步，造成instance判断都为空，所以会产生不只一个实例化对象。 123if(instance==null)&#123;//第一次使用时才实例化对象 instance=new Singleton();&#125; 针对此问题，则需要进行同步处理，同步自然会想到synchronized关键字。修改如下所示： 1234567//需要在第一次使用时生成实例，所以为了线程安全，使用synchronized关键字来确保只会生成单例public static synchronized Singleton getInstance()&#123; if(instance==null)&#123; instance=new Singleton(); &#125; return instance;&#125; 这个时候确实实现了同步，但是效率比较低，代价比较大。因为代码里面只有一个地方需要同步处理：instance实例化对象处理部分，在以上修改直接添加synchronized 显得草率了，所以这里需要更加合理的进行同步处理。 在懒汉式实现单例模式的代码中，有使用synchronized关键字来同步获取实例，保证单例的唯一性，但是上面的代码在每一次执行时都要进行同步和判断，无疑会拖慢速度，使用双重加锁机制正好可以解决这个问题，修改后整个代码如下所示。 123456789101112131415161718192021222324/** * 单例模式-懒汉式 */public class Singleton &#123; //私有静态方法，防止被引用，此处赋值为null，目的是实现延迟加载 private static volatile Singleton instance=null; //构造方法私有化，防止被实例化 private Singleton()&#123; &#125; public static Singleton getInstance()&#123; //需要在第一次使用时生成实例，所以为了线程安全，使用synchronized关键字来确保只会生成单例 if(instance==null)&#123;//第一次使用时才实例化对象 synchronized(Singleton.class)&#123;//反射机制 if(instance==null)&#123; instance=new Singleton(); &#125; &#125; &#125; return instance; &#125; public void print()&#123; System.out.println(\"Hello world\"); &#125;&#125; 双重加锁机制，这里的双重指的的双重判断，而加锁单指那个synchronized。为什么要进行双重判断，其实很简单，第一重判断，如果单例已经存在，那么就不再需要进行同步操作，而是直接返回这个实例，如果没有创建，才会进入同步块，同步块的目的与之前相同，目的是为了防止有两个调用同时进行时，导致生成多个实例，有了同步块，每次只能有一个线程调用能访问同步块内容，当第一个抢到锁的调用获取了实例之后，这个实例就会被创建，之后的所有调用都不会进入同步块，直接在第一重判断就返回了单例。至于第二个判断，有点查遗补漏的意味在内。 关于锁内部的第二重空判断的作用，当多个线程一起到达锁位置时，进行锁竞争，其中一个线程获取锁，如果是第一次进入则dl为null，会进行单例对象的创建，完成后释放锁，其他线程获取锁后就会被空判断拦截，直接返回已创建的单例对象。不论如何，使用了双重加锁机制后，程序的执行速度有了显著提升，不必每次都同步加锁。 volatile关键字的含义是：被其所修饰的变量的值不会被本地线程缓存，所有对该变量的读写都是直接操作共享内存来实现，从而确保多个线程能正确的处理该变量。该关键字可能会屏蔽掉虚拟机中的一些代码优化，所以其运行效率可能不是很高，所以，一般情况下，并不建议使用双重加锁机制，酌情使用。","categories":[{"name":"Java","slug":"Java","permalink":"http://yanhq.top/categories/Java/"}],"tags":[{"name":"-单例模式","slug":"单例模式","permalink":"http://yanhq.top/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"http://yanhq.top/categories/Java/"}]},{"title":"Java对象序列化","slug":"Java对象序列化","date":"2019-11-12T09:08:39.006Z","updated":"2019-11-12T09:14:45.714Z","comments":true,"path":"2019/11/12/Java对象序列化/","link":"","permalink":"http://yanhq.top/2019/11/12/Java%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96/","excerpt":"序列化 将内存中的对象以二进制流的形式进行处理，可以实现对象的保存或网络传输。 Java中的对象序列化，序列化的是什么？是对象的状态、更具体的说就是对象中的字段及其值，因为这些值正好描述了对象的状态。","text":"序列化 将内存中的对象以二进制流的形式进行处理，可以实现对象的保存或网络传输。 Java中的对象序列化，序列化的是什么？是对象的状态、更具体的说就是对象中的字段及其值，因为这些值正好描述了对象的状态。 序列化的使用 要想一个类拥有序列化、反序列化功能，最简单的方法就是实现java.io.Serializable接口，这个接口是一个标记接口（marker Interface），即其内部无任何属性与方法。 虽然要实现序列化只需要实现Serializable接口即可，但这只是让类的对象拥有可被序列化和反序列化的功能，它自己并不会自动实现序列化与反序列化，我们需要编写代码来进行序列化与反序列化。 这就需要使用ObjectOutputStream类的writeObject()方法与readObject()方法，这两个方法分别对应于将对象写入到流中（序列化），从流中读取对象（反序列化）。 transient关键字 Java序列化的的是对象的非静态字段及其值。而transient关键字正是使用在实现了Serializable接口的目标类的字段中，凡是被该关键字修饰的字段，都将被序列化过滤掉，即不会被序列化。","categories":[{"name":"Java","slug":"Java","permalink":"http://yanhq.top/categories/Java/"}],"tags":[{"name":"Java序列化","slug":"Java序列化","permalink":"http://yanhq.top/tags/Java%E5%BA%8F%E5%88%97%E5%8C%96/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"http://yanhq.top/categories/Java/"}]},{"title":"String、StringBuffer和StringBuilder类的区别","slug":"String、StringBuffer和StringBuilder类的区别","date":"2019-11-12T09:08:15.558Z","updated":"2019-11-12T09:14:08.002Z","comments":true,"path":"2019/11/12/String、StringBuffer和StringBuilder类的区别/","link":"","permalink":"http://yanhq.top/2019/11/12/String%E3%80%81StringBuffer%E5%92%8CStringBuilder%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"#StringString类是final类故不可以继承，也就意味着String引用的字符串内容是不能被修改。String有两种实例化方式： （1）直接赋值（例中，String str = “Hello”;就是直接赋值实例化了） （2）使用new调用构造方法完成实例化；","text":"#StringString类是final类故不可以继承，也就意味着String引用的字符串内容是不能被修改。String有两种实例化方式： （1）直接赋值（例中，String str = “Hello”;就是直接赋值实例化了） （2）使用new调用构造方法完成实例化； 123456789public class JavaTest &#123; public static void main(String[] args) &#123; String str = \"Hello\"; str = str + \" World\"; System.out.println(\"str=\" + str); &#125;&#125;运行结果：str=Hello World 要注意的是：String类对象内容不能修改，但并不代表其引用不能改变，下面通过内存的分配图说明字符串不可改变的真正含义：从上图可知，String对象内容的改变实际上是通过内存地址“断开-连接”变化来完成的，而原字符串中的内容并没有任何的改变。String str = “Hello”;和str = str + “ World”;实质上是开辟了三个内存空间，str只是由原来指向”hello”变为指向“hello world”而已，而其原来的指向内容，是没有改变的。 因此，在每次对 String 类型进行改变的时候其实都等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象，String的操作是改变赋值地址而不是改变值操作。所以经常改变内容的字符串最好不要用 String ，因为每次生成对象都会对系统性能产生影响，特别当内存中无引用对象多了以后， JVM 的 GC 就会开始工作，那速度是一定会相当慢的。不仅效率低下，而且大量浪费有限的内存空间。#StringBuffer StringBuffer是内容可变类和线程安全的字符串操作类，任何对它指向的字符串的操作都不会产生新的对象。 每个StringBuffer对象都有一定的缓冲区容量，当字符串大小没有超过容量时，不会分配新的容量，当字符串大小超过容量时，会自动增加容量。使用 StringBuffer 类则结果就不一样了，每次结果都会对 StringBuffer 对象本身进行操作，而不是生成新的对象，再改变对象引用。所以在一般情况下我们推荐使用 StringBuffer ，特别是字符串对象经常改变的情况下。而在某些特别情况下， String 对象的字符串拼接其实是被 JVM 解释成了 StringBuffer 对象的拼接，所以这些时候 String 对象的速度并不会比 StringBuffer 对象慢，而特别是以下的字符串对象生成中， String 效率是要比 StringBuffer 快的： 12String S1 = “This is only a” + “ simple” + “ test”;StringBuffer Sb = new StringBuilder(“This is only a”).append(“ simple”).append(“ test”); 可将字符串缓冲区安全地用于多个线程。可以在必要时对这些方法进行同步，因此任意特定实例上的所有操作就好像是以串行顺序发生的，该顺序与所涉及的每个线程进行的方法调用顺序一致。 StringBuffer 上的主要操作是 append 和 insert 方法，可重载这些方法，以接受任意类型的数据。每个方法都能有效地将给定的数据转换成字符串，然后将该字符串的字符追加或插入到字符串缓冲区中。append 方法始终将这些字符添加到缓冲区的末端；而 insert 方法则在指定的点添加字符。 例如，如果 z 引用一个当前内容是“start”的字符串缓冲区对象，则此方法调用 z.append(“le”) 会使字符串缓冲区包含“startle”，而 z.insert(4, “le”) 将更改字符串缓冲区，使之包含“starlet”。 123StringBuffer buf=new StringBuffer(); //分配长16字节的字符缓冲区 StringBuffer buf=new StringBuffer(512); //分配长512字节的字符缓冲区 StringBuffer buf=new StringBuffer(\"this is a test\")//在缓冲区中存放了字符串，并在后面预留了16字节的空缓冲区。 #StringBuilderjava.lang.StringBuilder一个可变的字符序列是5.0新增的。此类提供一个与 StringBuffer 兼容的 API，使用基本相同，但不保证同步，不是线程安全的。#总结如果要操作少量的数据用 = String单线程操作字符串缓冲区 下操作大量数据 = StringBuilder多线程操作字符串缓冲区 下操作大量数据 = StringBuffer 参考：https://blog.csdn.net/guyuealian/article/details/50935168https://blog.csdn.net/guyuealian/article/details/47059079","categories":[{"name":"Java","slug":"Java","permalink":"http://yanhq.top/categories/Java/"}],"tags":[{"name":"StringBuffer StringBuilder","slug":"StringBuffer-StringBuilder","permalink":"http://yanhq.top/tags/StringBuffer-StringBuilder/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"http://yanhq.top/categories/Java/"}]},{"title":"Java实现HTTP请求工具类","slug":"Java实现HTTP请求工具类","date":"2019-11-12T09:06:32.402Z","updated":"2019-11-12T09:11:32.560Z","comments":true,"path":"2019/11/12/Java实现HTTP请求工具类/","link":"","permalink":"http://yanhq.top/2019/11/12/Java%E5%AE%9E%E7%8E%B0HTTP%E8%AF%B7%E6%B1%82%E5%B7%A5%E5%85%B7%E7%B1%BB/","excerpt":"","text":"废话不多说，直接上代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133import javax.servlet.http.HttpServletRequest;import java.io.*;import java.net.HttpURLConnection;import java.net.URL;import java.net.URLEncoder;import java.util.Map;public class HttpUtil &#123; private static String POST = \"POST\"; private static String GET = \"GET\"; private static String CONTENT_TYPE_URLENCODED = \"application/x-www-form-urlencoded\"; private static String CONTENT_TYPE_JSON = \"application/json\"; private static String CONTENT_TYPE_TEXT = \"text/plain; charset=UTF-8\"; private static String httpRequest(String method, String contentType, String urlStr, String paras) throws IOException &#123; PrintWriter out=null; BufferedReader in = null; StringBuffer content = new StringBuffer(); try &#123; URL url = new URL(urlStr); HttpURLConnection con = (HttpURLConnection) url.openConnection(); // 设置通用的请求属性 con.setRequestProperty(\"accept\", \"*/*\"); con.setRequestProperty(\"connection\", \"Keep-Alive\"); con.setRequestProperty(\"Content-Type\",contentType); con.setRequestProperty(\"user-agent\", \"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)\"); con.setConnectTimeout(10000); con.setReadTimeout(10000); con.setRequestMethod(method); if (paras != null &amp;&amp; !paras.isEmpty()) &#123; con.setDoOutput(true); out = new PrintWriter(new OutputStreamWriter(con.getOutputStream(), \"UTF-8\")); out.print(paras); out.flush(); &#125; in = new BufferedReader(new InputStreamReader(con.getInputStream(),\"utf-8\")); String inputLine; while ((inputLine = in.readLine()) != null) &#123; content.append(inputLine); &#125; &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; // 关闭输出流、输入流 finally &#123; if (out != null) &#123; out.close(); &#125; if (in != null) &#123; in.close(); &#125; &#125; return content.toString(); &#125; private static class ParameterStringBuilder &#123; public static String getParamsString(Map&lt;String, String&gt; params) throws UnsupportedEncodingException &#123; StringBuilder result = new StringBuilder(); for (Map.Entry&lt;String, String&gt; entry : params.entrySet()) &#123; result.append(URLEncoder.encode(entry.getKey(), \"UTF-8\")); result.append(\"=\"); result.append(URLEncoder.encode(entry.getValue(), \"UTF-8\")); result.append(\"&amp;\"); &#125; String resultString = result.toString(); return resultString.length() &gt; 0 ? resultString.substring(0, resultString.length() - 1) : resultString; &#125; &#125; /** * GET请求 * @param url * @param paras * @return */ public static String httpGetRequest(String url, String paras)&#123; try &#123; return httpRequest(GET, CONTENT_TYPE_URLENCODED, url, paras); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return \"\"; &#125; /** * POST请求 * @param url * @param paras * @return */ public static String httpPostRequest(String url, String paras)&#123; try &#123; return httpRequest(POST, CONTENT_TYPE_JSON, url, paras); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return \"\"; &#125; /** * 通过inputStream获取入参 * @param request * @return */ public static String parseRequest(HttpServletRequest request)&#123; StringBuffer buffer = new StringBuffer() ; try &#123; InputStream in = request.getInputStream(); BufferedReader br = new BufferedReader(new InputStreamReader(in,\"UTF-8\")); String line = \"\"; while ((line = br.readLine()) != null) &#123; buffer.append(line); &#125; br.close(); in.close(); &#125;catch (IOException e)&#123; System.out.println(\"\"); &#125; return buffer.toString(); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://yanhq.top/categories/Java/"}],"tags":[{"name":"-HTTP请求","slug":"HTTP请求","permalink":"http://yanhq.top/tags/HTTP%E8%AF%B7%E6%B1%82/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"http://yanhq.top/categories/Java/"}]},{"title":"Oracle游标循环","slug":"oracle游标循环","date":"2019-11-12T09:06:15.539Z","updated":"2019-11-12T09:13:20.466Z","comments":true,"path":"2019/11/12/oracle游标循环/","link":"","permalink":"http://yanhq.top/2019/11/12/oracle%E6%B8%B8%E6%A0%87%E5%BE%AA%E7%8E%AF/","excerpt":"","text":"游标循环的使用实例：12345678910111213141516171819202122232425262728293031323334procedure testPro(out_retVal out clob) is v_cnt number(12); --先查询，游标保存多条记录 cursor cur is select t.phone_number,t.ext_nbr from Test t where t.status_cd=0 and ((sysdate - t.send_time) * 24)&gt;1; begin v_json := json(); v_cnt :=0; begin --循环游标，取出参数 for x in cur loop v_phone_number :=x.phone_number; v_ext_nbr :=x.ext_nbr; --执行要做的事 --记录数量 v_cnt:=v_cnt+1; end loop; --如果数量大于0，执行某事件 if v_cnt&gt;0 then --执行某事件 END IF; v_json.put('retVal', '完成'); v_json.put('retFlag', 0); out_retVal := v_json.to_char(); exception when others then v_json.put('retVal', 'oracle exception'); v_json.put('retFlag', 2); out_retVal := v_json.to_char(); end;","categories":[{"name":"Oracle","slug":"Oracle","permalink":"http://yanhq.top/categories/Oracle/"}],"tags":[{"name":"oracle游标循环","slug":"oracle游标循环","permalink":"http://yanhq.top/tags/oracle%E6%B8%B8%E6%A0%87%E5%BE%AA%E7%8E%AF/"}],"keywords":[{"name":"Oracle","slug":"Oracle","permalink":"http://yanhq.top/categories/Oracle/"}]},{"title":"Oracle数据库表空间清理","slug":"Oracle 表空间清理","date":"2019-11-12T09:05:41.692Z","updated":"2019-11-12T09:12:51.185Z","comments":true,"path":"2019/11/12/Oracle 表空间清理/","link":"","permalink":"http://yanhq.top/2019/11/12/Oracle%20%E8%A1%A8%E7%A9%BA%E9%97%B4%E6%B8%85%E7%90%86/","excerpt":"今天维护了多年的Oracle数据库突然报表空间不足95%告警，由于系统马上升级下线，上面不再批准扩展表空间了，那只能自己去清理一些历史数据。1、先查询表空间使用情况","text":"今天维护了多年的Oracle数据库突然报表空间不足95%告警，由于系统马上升级下线，上面不再批准扩展表空间了，那只能自己去清理一些历史数据。1、先查询表空间使用情况 12345678910111213141516--查询表空间使用情况SELECT a.tablespace_name \"表空间名\", total \"表空间大小\", free \"表空间剩余大小\", (total - free) \"表空间使用大小\", total / (1024 * 1024 * 1024) \"表空间大小(G)\", free / (1024 * 1024 * 1024) \"表空间剩余大小(G)\", (total - free) / (1024 * 1024 * 1024) \"表空间使用大小(G)\", round((total - free) / total, 4) * 100 \"使用率 %\" FROM (SELECT tablespace_name, SUM(bytes) free FROM dba_free_space GROUP BY tablespace_name) a, (SELECT tablespace_name, SUM(bytes) total FROM dba_data_files GROUP BY tablespace_name) b WHERE a.tablespace_name = b.tablespace_name; 2、查询具体哪些表占用的空间较大，好针对性清理这些占用大的表 1234--查询表所占空间大小select segment_name \"表名\", bytes/(1024 * 1024 * 1024) \"占用（G）\"from user_segments where segment_type = 'TABLE'; 3、清理可以有drop表、truncate清空数据、delete删除数据4、delete和truncate有时候并不能释放表空间，需要执行以下脚本释放 12345--收缩表空间alter table CEP.cep_archive_data enable row movement;alter table CEP.cep_archive_data shrink space compact;alter table CEP.cep_archive_data shrink space;alter table CEP.cep_archive_data disable row movement;","categories":[{"name":"Oracle","slug":"Oracle","permalink":"http://yanhq.top/categories/Oracle/"}],"tags":[{"name":"oracle表空间清理","slug":"oracle表空间清理","permalink":"http://yanhq.top/tags/oracle%E8%A1%A8%E7%A9%BA%E9%97%B4%E6%B8%85%E7%90%86/"}],"keywords":[{"name":"Oracle","slug":"Oracle","permalink":"http://yanhq.top/categories/Oracle/"}]},{"title":"初识云原生","slug":"初识云原生","date":"2019-11-12T08:59:02.278Z","updated":"2019-11-12T09:03:25.677Z","comments":true,"path":"2019/11/12/初识云原生/","link":"","permalink":"http://yanhq.top/2019/11/12/%E5%88%9D%E8%AF%86%E4%BA%91%E5%8E%9F%E7%94%9F/","excerpt":"随着虚拟化技术的成熟和分布式架构的普及，用来部署、管理和运行应用的云平台被越来越多的提及。IaaS、PaaS和SaaS是云计算的3种基本服务类型，它们是关注硬件基础设施的基础设施即服务、关注软件和中间件平台的平台即服务以及关注业务应用的软件即服务。","text":"随着虚拟化技术的成熟和分布式架构的普及，用来部署、管理和运行应用的云平台被越来越多的提及。IaaS、PaaS和SaaS是云计算的3种基本服务类型，它们是关注硬件基础设施的基础设施即服务、关注软件和中间件平台的平台即服务以及关注业务应用的软件即服务。 云原生不是一个产品，而是一套技术体系和一套方法论，而数字化转型是思想先行，从内到外的整体变革。更确切地说，它是一种文化，更是一种潮流，是云计算的一个必然导向。“云原生计算”是一个用于部署微服务应用的开源软件堆栈，其方式是把各个组件都打包到容器中并动态调度容器以优化计算资源利用率。 在容器技术、可持续交付、编排系统等开源社区的推动下，以及微服务等开发理念的带动下，应用上云已经是不可逆转的趋势。随着云化技术的不断进展，云原生的概念也应运而生。它的内容非常多，包括DevOps、持续交付（Continuous Delivery）、微服务（MicroServices）、敏捷基础设施（Agile Infrastructure）和12要素（The Twelve-Factor App）等几大主题，不但包括根据业务能力对公司进行文化、组织架构的重组与建设，也包括方法论与原则，还有具体的操作工具。采用基于云原生的技术和管理方法，可以更好地把业务生于“云”或迁移到云平台，从而享受“云”的高效和持续的服务能力。云原生的四要素：持续交付、DevOps、微服务、容器CNCF(云原生计算基金会)认为云原生系统需包含的属性： 容器化封装：以容器为基础，提高整体开发水平，形成代码和组件重用，简化云原生应用程序的维护。在容器中运行应用程序和进程，并作为应用程序部署的独立单元，实现高水平资源隔离。 自动化管理：统一调度和管理中心，从根本上提高系统和资源利用率，同时降低运维成本。 面向微服务：通过松耦合方式，提升应用程序的整体敏捷性和可维护性。","categories":[{"name":"云原生","slug":"云原生","permalink":"http://yanhq.top/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/"}],"tags":[{"name":"-云原生","slug":"云原生","permalink":"http://yanhq.top/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/"}],"keywords":[{"name":"云原生","slug":"云原生","permalink":"http://yanhq.top/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/"}]},{"title":"为什么不建议使用存储过程了","slug":"为什么不建议使用存储过程了","date":"2019-11-12T08:58:51.315Z","updated":"2019-11-12T09:04:04.629Z","comments":true,"path":"2019/11/12/为什么不建议使用存储过程了/","link":"","permalink":"http://yanhq.top/2019/11/12/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E4%BA%86/","excerpt":"在公司的系统升级换代中，明确规定在数据库开发中不允许再使用存储过程了，以前的老一代系统中，很多复杂的业务逻辑都是存储过程写的，那为什么风光无限的存储过程不再被宠幸了呢？首先了解下什么是存储过程，它有什么好处，又有哪些劣势，为什么现在都不建议使用存储过程呢？","text":"在公司的系统升级换代中，明确规定在数据库开发中不允许再使用存储过程了，以前的老一代系统中，很多复杂的业务逻辑都是存储过程写的，那为什么风光无限的存储过程不再被宠幸了呢？首先了解下什么是存储过程，它有什么好处，又有哪些劣势，为什么现在都不建议使用存储过程呢？ 什么是存储过程存储过程（Stored Procedure）是在大型数据库系统中，一组为了完成特定功能的SQL 语句集，预先编译好存储在数据库中，一次编译后永久有效，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。它是数据库中的一个重要对象。 存储过程的优点1、可以减少程序在调用DB时候的信息传输量（其实减少的只有Request的时候） 2、存储过程是预先优化和预编译的，节省每次运行编译的时间，所以一般情况下认为存储过程的性能是优于sql语句的。 3、对调用者可以隐藏数据库的复杂性，将数据组装的过程封装。 4、参数化的存储过程可以防止SQL注入式攻击，而且可以将Grant、Deny以及Revoke权限应用于存储过程。 5、如果业务开发中，数据人员和业务代码人员是分离的，业务人员可以不用关心数据，直接调用存储过程，更加面向分层开发设计理念。 存储过程的缺点1、存储过程这种“一次优化，多次使用”的策略节省了每次执行时候编译的时间，但也是该策略导致了一个致命的缺点：可能会使用错误的执行计划。 2、存储过程难以调试，虽然有些DB提供了调试功能，但是一般的账号根本就没有那种权限，更何况线上的数据库不可能会给你调试权限的，再进一步就算能调试效果也比程序的调试效果要差很多。 3、可移植性差，当碰到切换数据种类的时候，存储过程基本就会歇菜。 4、如果业务数据模型有变动，存储过程必须跟着业务代码一起更改，如果是大型项目，这种改动是空前的，是要命的。 为什么不建议使用存储过程以上存储过程的优缺点，表面看来存储过程的优势还是不少的，这也说明为什么老一辈程序员有很多喜欢写存储过程。但随着软件行业业务日益复杂化，存储过程现在复杂业务及大流量面前其实有点有心无力。 1、采用存储过程操作数据在网络数据量传输上确实比直接使用sql语句要少很多，但这通常并不是操作数据系统性能的瓶颈，在一次操作数据的过程中，假设用时100毫秒，采用存储过程节省数据传输时间0.5毫秒（就算是5毫秒），我觉得这点时间基本可以忽略。 2、存储过程是只优化一次的，这有时候恰恰是个缺陷。有的时候随着数据量的增加或者数据结构的变化，原来存储过程选择的执行计划也许并不是最优的了，所以这个时候需要手动干预或者重新编译了，而什么时候执行计划不是最优的了这个平衡点，预先无法知晓，这就导致了有些应用突然会变慢，程序员处于懵逼的状态。 3、存储过程确实可以对调用方隐藏数据库的细节，但是这种业务代码人员和数据库设计人员是两个团队的情况又有多少呢，如果真是两个团队，那业务就需要两个团队来理解和沟通，我想沟通的成本也一定很高，而且分歧更容易产生。 我自己是有切身感受的，在接手的旧系统，令我头疼的不是业务，很多重要的业务逻辑都写在上千行的存储过程，关键还没有调试的权限，在生产上也不能调试啊，出现个报错，都不知道如何怎么下手了。尤其是当有业务改动上线时，必须要停掉所以相关的存储过程重新编译，总有一些莫名其妙的问题出现，相当烦躁！ 我认为数据库就应该做存储相关的事情，这也是它最擅长的事。现在的互联网的大流量冲击下，如果把业务处理及计算放在数据库上，数据库的负载压力会特别大，肯定是顶不住的。再说了，现在搞的都是分布式集群，分布式数据库，存储过程已经不能胜任了。","categories":[{"name":"Java","slug":"Java","permalink":"http://yanhq.top/categories/Java/"}],"tags":[{"name":"-存储过程","slug":"存储过程","permalink":"http://yanhq.top/tags/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"http://yanhq.top/categories/Java/"}]},{"title":"TPS、QPS及并发数等概念","slug":"TPS、QPS及并发数等概念","date":"2019-11-12T08:58:37.513Z","updated":"2019-11-12T09:02:36.172Z","comments":true,"path":"2019/11/12/TPS、QPS及并发数等概念/","link":"","permalink":"http://yanhq.top/2019/11/12/TPS%E3%80%81QPS%E5%8F%8A%E5%B9%B6%E5%8F%91%E6%95%B0%E7%AD%89%E6%A6%82%E5%BF%B5/","excerpt":"在日常的工作中经常会讲到吞吐量、并发量等概念，查询了下相关资料，在这里记录下对吞吐量（TPS）、QPS、并发数、响应时间（RT）几个概念做下了解，查自百度百科。","text":"在日常的工作中经常会讲到吞吐量、并发量等概念，查询了下相关资料，在这里记录下对吞吐量（TPS）、QPS、并发数、响应时间（RT）几个概念做下了解，查自百度百科。 响应时间(RT) 响应时间是指系统对请求作出响应的时间。直观上看，这个指标与人对软件性能的主观感受是非常一致的，因为它完整地记录了整个计算机系统处理请求的时间。由于一个系统通常会提供许多功能，而不同功能的处理逻辑也千差万别，因而不同功能的响应时间也不尽相同，甚至同一功能在不同输入数据的情况下响应时间也不相同。所以，在讨论一个系统的响应时间时，人们通常是指该系统所有功能的平均时间或者所有功能的最大响应时间。当然，往往也需要对每个或每组功能讨论其平均响应时间和最大响应时间。 吞吐量(Throughput) 吞吐量是指系统在单位时间内处理请求的数量。对于无并发的应用系统而言，吞吐量与响应时间成严格的反比关系，实际上此时吞吐量就是响应时间的倒数。前面已经说过，对于单用户的系统，响应时间（或者系统响应时间和应用延迟时间）可以很好地度量系统的性能，但对于并发系统，通常需要用吞吐量作为性能指标。 对于一个多用户的系统，如果只有一个用户使用时系统的平均响应时间是t，当有你n个用户使用时，每个用户看到的响应时间通常并不是n×t，而往往比n×t小很多（当然，在某些特殊情况下也可能比n×t大，甚至大很多）。这是因为处理每个请求需要用到很多资源，由于每个请求的处理过程中有许多不走难以并发执行，这导致在具体的一个时间点，所占资源往往并不多。也就是说在处理单个请求时，在每个时间点都可能有许多资源被闲置，当处理多个请求时，如果资源配置合理，每个用户看到的平均响应时间并不随用户数的增加而线性增加。实际上，不同系统的平均响应时间随用户数增加而增长的速度也不大相同，这也是采用吞吐量来度量并发系统的性能的主要原因。一般而言，吞吐量是一个比较通用的指标，两个具有不同用户数和用户使用模式的系统，如果其最大吞吐量基本一致，则可以判断两个系统的处理能力基本一致。 并发用户数 并发用户数是指系统可以同时承载的正常使用系统功能的用户的数量。与吞吐量相比，并发用户数是一个更直观但也更笼统的性能指标。实际上，并发用户数是一个非常不准确的指标，因为用户不同的使用模式会导致不同用户在单位时间发出不同数量的请求。一网站系统为例，假设用户只有注册后才能使用，但注册用户并不是每时每刻都在使用该网站，因此具体一个时刻只有部分注册用户同时在线，在线用户就在浏览网站时会花很多时间阅读网站上的信息，因而具体一个时刻只有部分在线用户同时向系统发出请求。这样，对于网站系统我们会有三个关于用户数的统计数字：注册用户数、在线用户数和同时发请求用户数。由于注册用户可能长时间不登陆网站，使用注册用户数作为性能指标会造成很大的误差。而在线用户数和同事发请求用户数都可以作为性能指标。相比而言，以在线用户作为性能指标更直观些，而以同时发请求用户数作为性能指标更准确些。 QPS每秒查询率(Query Per Second) 每秒查询率QPS是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准，在因特网上，作为域名系统服务器的机器的性能经常用每秒查询率来衡量。对应fetches/sec，即每秒的响应请求数，也即是最大吞吐能力。 （看来是类似于TPS，只是应用于特定场景的吞吐量）","categories":[{"name":"Java","slug":"Java","permalink":"http://yanhq.top/categories/Java/"}],"tags":[{"name":"-并发数 -QPS","slug":"并发数-QPS","permalink":"http://yanhq.top/tags/%E5%B9%B6%E5%8F%91%E6%95%B0-QPS/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"http://yanhq.top/categories/Java/"}]},{"title":"DBVisualizer工具连接Phoenix","slug":"DBVisualizer工具连接Phoenix","date":"2019-11-12T08:58:24.873Z","updated":"2019-11-12T09:00:35.141Z","comments":true,"path":"2019/11/12/DBVisualizer工具连接Phoenix/","link":"","permalink":"http://yanhq.top/2019/11/12/DBVisualizer%E5%B7%A5%E5%85%B7%E8%BF%9E%E6%8E%A5Phoenix/","excerpt":"","text":"为了避免每次远程主机操作phoenix的麻烦，这里介绍下使用DBVisualizer工具连接Phoenix操作。1、工具清单DBVisualizer 我这里是版本V9.0HBase 和 Phoenix 部署在云主机上phoenix-client-4.7.0.2.6.5.0-292.jarhbase-site.xml2、准备（1）phoenix-client-4.7.0.2.6.5.0-292.jar包从云主机上的Phoenix安装目录下载（2）hbase-site.xml从云主机上的HBase安装目录下载，我这里是从Ambari管理界面下载的3、安装DBVisualizer工具安装步骤就不具体描述了，双击exe安装包一步一步下去就可以。（1）安装好了，打开Tools——Driver Manager 新建一个phoenix驱动（2）把hbase-site.xml文件拷贝到安装目录下的resource文件夹中（3）配置host在安装phoenix的云主机上找到host配置copy到本地windows下的host中（4）配置phoenix连接以上操作就能正常使用DBVisualizer工具连接Phoenix进行操作了。","categories":[{"name":"Phoenix","slug":"Phoenix","permalink":"http://yanhq.top/categories/Phoenix/"}],"tags":[{"name":"-DBVisualizer","slug":"DBVisualizer","permalink":"http://yanhq.top/tags/DBVisualizer/"}],"keywords":[{"name":"Phoenix","slug":"Phoenix","permalink":"http://yanhq.top/categories/Phoenix/"}]},{"title":"Spring MVC与Spring Boot的区别","slug":"Spring MVC与Spring Boot的区别","date":"2019-11-12T08:58:00.653Z","updated":"2019-11-12T09:01:45.639Z","comments":true,"path":"2019/11/12/Spring MVC与Spring Boot的区别/","link":"","permalink":"http://yanhq.top/2019/11/12/Spring%20MVC%E4%B8%8ESpring%20Boot%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"SpringSpring 框架就像一个家族，有众多衍生产品例如 boot、security、jpa等等。但他们的基础都是Spring 的 ioc和 aop ioc 提供了依赖注入的容器 aop ，解决了面向横切面的编程，然后在此两者的基础上实现了其他延伸产品的高级功能。Spring MVC是基于 Servlet 的一个 MVC 框架 主要解决 WEB 开发的问题，因为 Spring 的配置非常复杂，各种XML、 JavaConfig、hin处理起来比较繁琐。于是为了简化开发者的使用，从而创造性地推出了Spring boot，约定优于配置，简化了spring的配置流程。","text":"SpringSpring 框架就像一个家族，有众多衍生产品例如 boot、security、jpa等等。但他们的基础都是Spring 的 ioc和 aop ioc 提供了依赖注入的容器 aop ，解决了面向横切面的编程，然后在此两者的基础上实现了其他延伸产品的高级功能。Spring MVC是基于 Servlet 的一个 MVC 框架 主要解决 WEB 开发的问题，因为 Spring 的配置非常复杂，各种XML、 JavaConfig、hin处理起来比较繁琐。于是为了简化开发者的使用，从而创造性地推出了Spring boot，约定优于配置，简化了spring的配置流程。 说得更简便一些：Spring 最初利用“工厂模式”（DI）和“代理模式”（AOP）解耦应用组件。大家觉得挺好用，于是按照这种模式搞了一个 MVC框架（一些用Spring 解耦的组件），用开发 web 应用（ SpringMVC ）。然后有发现每次开发都写很多样板代码，为了简化工作流程，于是开发出了一些“懒人整合包”（starter），这套就是 Spring Boot。 Spring MVC的功能Spring MVC提供了一种轻度耦合的方式来开发web应用。 Spring MVC是Spring的一个模块，式一个web框架。通过Dispatcher Servlet, ModelAndView 和 View Resolver，开发web应用变得很容易。解决的问题领域是网站应用程序或者服务开发——URL路由、Session、模板引擎、静态Web资源等等。 Spring Boot的功能Spring Boot实现了自动配置，降低了项目搭建的复杂度。 众所周知Spring框架需要进行大量的配置，Spring Boot引入自动配置的概念，让项目设置变得很容易。Spring Boot本身并不提供Spring框架的核心特性以及扩展功能，只是用于快速、敏捷地开发新一代基于Spring框架的应用程序。也就是说，它并不是用来替代Spring的解决方案，而是和Spring框架紧密结合用于提升Spring开发者体验的工具。同时它集成了大量常用的第三方库配置(例如Jackson, JDBC, Mongo, Redis, Mail等等)，Spring Boot应用中这些第三方库几乎可以零配置的开箱即用(out-of-the-box)，大部分的Spring Boot应用都只需要非常少量的配置代码，开发者能够更加专注于业务逻辑。 Spring Boot只是承载者，辅助你简化项目搭建过程的。如果承载的是WEB项目，使用Spring MVC作为MVC框架，那么工作流程和你上面描述的是完全一样的，因为这部分工作是Spring MVC做的而不是Spring Boot。 对使用者来说，换用Spring Boot以后，项目初始化方法变了，配置文件变了，另外就是不需要单独安装Tomcat这类容器服务器了，maven打出jar包直接跑起来就是个网站，但你最核心的业务逻辑实现与业务流程实现没有任何变化。 所以，用最简练的语言概括就是： Spring 是一个“引擎”；Spring MVC 是基于Spring的一个 MVC 框架 ；Spring Boot 是基于Spring4的条件注册的一套快速开发整合包。 这是从知乎上看到的，觉得说的挺好，分享下，源址：https://www.zhihu.com/question/64671972/answer/223383505","categories":[{"name":"Java","slug":"Java","permalink":"http://yanhq.top/categories/Java/"}],"tags":[{"name":"-Spring Boot -Spring MVC","slug":"Spring-Boot-Spring-MVC","permalink":"http://yanhq.top/tags/Spring-Boot-Spring-MVC/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"http://yanhq.top/categories/Java/"}]},{"title":"Docker的概念","slug":"Docker的概念","date":"2019-11-12T08:39:23.081Z","updated":"2019-11-12T08:49:28.667Z","comments":true,"path":"2019/11/12/Docker的概念/","link":"","permalink":"http://yanhq.top/2019/11/12/Docker%E7%9A%84%E6%A6%82%E5%BF%B5/","excerpt":"最近工作中遇到Docker容器的使用，也查了一些文档了解了一下，发现了自认为一篇把Docker讲述的很通俗易懂的文章，于是便想分享出来让更多的人收益。","text":"最近工作中遇到Docker容器的使用，也查了一些文档了解了一下，发现了自认为一篇把Docker讲述的很通俗易懂的文章，于是便想分享出来让更多的人收益。 一 什么是容器1.1 容器的概念先来看看容器较为官方的解释 一句话概括容器：容器就是将软件打包成标准化单元，以用于开发、交付和部署。容器镜像是轻量的、可执行的独立软件包 ，包含软件运行所需的所有内容：代码、运行时环境、系统工具、系统库和设置。 容器化软件适用于基于Linux和Windows的应用，在任何环境中都能够始终如一地运行。 容器赋予了软件独立性，使其免受外在环境差异（例如，开发和预演环境的差异）的影响，从而有助于减少团队间在相同基础设施上运行不同软件时的冲突。 如果需要通俗的描述容器的话，我觉得容器就是一个存放东西的地方，就像书包可以装各种文具、衣柜可以放各种衣服、鞋架可以放各种鞋子一样。我们现在所说的容器存放的东西可能更偏向于应用比如网站、程序甚至是系统环境。1.2 图解物理机、虚拟机与容器关于虚拟机与容器的对比在后面会详细介绍到，这里只是通过网上的图片加深大家对于物理机、虚拟机与容器这三者的理解。物理机:虚拟机：容器： 通过上面这三张抽象图，我们可以大概可以通过类比概括出：容器虚拟化的是操作系统而不是硬件，容器之间是共享同一套操作系统资源的。虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统。因此容器的隔离级别会稍低一些。 二 什么是Docker说实话关于Docker是什么并太好说，下面我通过四点向你说明Docker到底是个什么东西。 Docker 是世界领先的软件容器平台。 Docker 使用 Google 公司推出的 Go 语言 进行开发实现，基于 Linux 内核的cgroup，namespace，以及AUFS类的UnionFS等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进 程，因此也称其为容器。Docke最初实现是基于 LXC. Docker 能够自动执行重复性任务，例如搭建和配置开发环境，从而解放了开发人员以便他们专注在真正重要的事情上：构建杰出的软件。 用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。2.2 Docker思想 集装箱 标准化： ①运输方式 ② 存储方式 ③ API接口 隔离 2.3 Docker容器的特点 轻量在一台机器上运行的多个 Docker 容器可以共享这台机器的操作系统内核；它们能够迅速启动，只需占用很少的计算和内存资源。镜像是通过文件系统层进行构造的，并共享一些公共文件。这样就能尽量降低磁盘用量，并能更快地下载镜像。 标准Docker 容器基于开放式标准，能够在所有主流 Linux 版本、Microsoft Windows 以及包括 VM、裸机服务器和云在内的任何基础设施上运行。 安全Docker 赋予应用的隔离性不仅限于彼此隔离，还独立于底层的基础设施。Docker 默认提供最强的隔离，因此应用出现问题，也只是单个容器的问题，而不会波及到整台机器。 2.4 为什么要用Docker Docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 “这段代码在我机器上没问题啊”这类问题；——一致的运行环境 可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。——更快速的启动时间 避免公用的服务器，资源会容易受到其他用户的影响。——隔离性 善于处理集中爆发的服务器使用压力；——弹性伸缩，快速扩展 可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。——迁移方便 使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。——持续交付和部署 三 容器 VS 虚拟机简单来说： 容器和虚拟机具有相似的资源隔离和分配优势，但功能有所不同，因为容器虚拟化的是操作系统，而不是硬件，因此容器更容易移植，效率也更高。 3.1 两者对比 传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便.3.2 容器与虚拟机 (VM) 总结容器是一个应用层抽象，用于将代码和依赖资源打包在一起。 多个容器可以在同一台机器上运行，共享操作系统内核，但各自作为独立的进程在用户空间中运行 。与虚拟机相比， 容器占用的空间较少（容器镜像大小通常只有几十兆），瞬间就能完成启动 。 虚拟机 (VM) 是一个物理硬件层抽象，用于将一台服务器变成多台服务器。 管理程序允许多个 VM 在一台机器上运行。每个VM都包含一整套操作系统、一个或多个应用、必要的二进制文件和库资源，因此 占用大量空间 。而且 VM 启动也十分缓慢 。 通过Docker官网，我们知道了这么多Docker的优势，但是大家也没有必要完全否定虚拟机技术，因为两者有不同的使用场景。虚拟机更擅长于彻底隔离整个运行环境。例如，云服务提供商通常采用虚拟机技术隔离不同的用户。而 Docker通常用于隔离不同的应用 ，例如前端，后端以及数据库。 3.3 容器与虚拟机 (VM)两者是可以共存的就我而言，对于两者无所谓谁会取代谁，而是两者可以和谐共存。 四 Docker基本概念Docker 包括三个基本概念： 镜像（Image） 容器（Container） 仓库（Repository） 理解了这三个概念，就理解了 Docker 的整个生命周期 4.1 镜像（Image）——一个特殊的文件系统 操作系统分为内核和用户空间。对于 Linux 而言，内核启动后，会挂载 root 文件系统为其提供用户空间支持。而Docker 镜像（Image），就相当于是一个 root 文件系统。 Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。 镜像不包含任何动态数据，其内容在构建之后也不会被改变。 Docker 设计时，就充分利用 Union FS的技术，将其设计为 分层存储的架构 。 镜像实际是由多层文件系统联合组成。 镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。 比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。 分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。 4.2 容器（Container)——镜像运行时的实体 镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等 。 容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的命名空间。前面讲过镜像使用的是分层存储，容器也是如此。 容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。 按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据 ，容器存储层要保持无状态化。所有的文件写入操作，都应该使用数据卷（Volume）、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主(或网络存储)发生读写，其性能和稳定性更高。数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此， 使用数据卷后，容器可以随意删除、重新 run ，数据却不会丢失。 4.3 仓库（Repository）——集中存放镜像文件的地方 镜像构建完成后，可以很容易的在当前宿主上运行，但是， 如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry就是这样的服务。 一个 Docker Registry中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。所以说：镜像仓库是Docker用来集中存放镜像文件的地方类似于我们之前常用的代码仓库。 通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本 。我们可以通过 &lt;仓库名&gt;:&lt;标签&gt;的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签.。 这里补充一下Docker Registry 公开服务和私有 Docker Registry的概念： Docker Registry 公开服务是开放给用户使用、允许用户管理镜像的 Registry 服务。一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。 最常使用的 Registry 公开服务是官方的 Docker Hub ，这也是默认的 Registry，并拥有大量的高质量的官方镜像，网址为：https://hub.docker.com/ 。在国内访问Docker Hub 可能会比较慢国内也有一些云服务商提供类似于 Docker Hub 的公开服务。比如 时速云镜像库、网易云镜像服务、DaoCloud 镜像市场、阿里云镜像库等。 除了使用公开服务外，用户还可以在 本地搭建私有 Docker Registry 。Docker 官方提供了 Docker Registry 镜像，可以直接使用做为私有 Registry 服务。开源的 Docker Registry 镜像只提供了 Docker Registry API 的服务端实现，足以支持 docker 命令，不影响使用。但不包含图形界面，以及镜像维护、用户管理、访问控制等高级功能。 最后谈谈：Build, Ship, and Run如果你搜索Docker官网，会发现如下的字样：“Docker - Build, Ship, and Run Any App, Anywhere”。那么Build, Ship, and Run到底是在干什么呢？ Build（构建镜像） ： 镜像就像是集装箱包括文件以及运行环境等等资源。 Ship（运输镜像） ：主机和仓库间运输，这里的仓库就像是超级码头一样。 Run （运行镜像） ：运行的镜像就是一个容器，容器就是运行程序的地方。 Docker 运行过程也就是去仓库把镜像拉到本地，然后用一条命令把镜像运行起来变成容器。所以，我们也常常将Docker称为码头工人或码头装卸工，这和Docker的中文翻译搬运工人如出一辙。 转载于微信公众号Java通关面试手册","categories":[{"name":"Docker","slug":"Docker","permalink":"http://yanhq.top/categories/Docker/"}],"tags":[{"name":"-Docker","slug":"Docker","permalink":"http://yanhq.top/tags/Docker/"}],"keywords":[{"name":"Docker","slug":"Docker","permalink":"http://yanhq.top/categories/Docker/"}]},{"title":"Java多线程读取多个文件","slug":"java 多线程读取多个文件","date":"2019-11-12T07:29:40.027Z","updated":"2019-11-12T08:50:46.194Z","comments":true,"path":"2019/11/12/java 多线程读取多个文件/","link":"","permalink":"http://yanhq.top/2019/11/12/java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AF%BB%E5%8F%96%E5%A4%9A%E4%B8%AA%E6%96%87%E4%BB%B6/","excerpt":"工具类代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import java.io.*;import java.util.List;import java.util.concurrent.CountDownLatch;/** * 多线程读取多个文件 */public class FileThread extends Thread&#123; private final CountDownLatch countDownLatch = new CountDownLatch(10); private int fileIndex; private List&lt;String&gt; filelist; private String filepath = \"D:\\\\LocalFtpServer\\\\data20181229\\\\\"; private String movepath = \"D:\\\\LocalFtpServer\\\\data20181229_01\\\\\"; public int getFileIndex() &#123; return fileIndex; &#125; public void setFileIndex(int fileIndex) &#123; this.fileIndex = fileIndex; &#125; public List&lt;String&gt; getFilelist() &#123; return filelist; &#125; public void setFilelist(List&lt;String&gt; filelist) &#123; this.filelist = filelist; &#125; @Override public void run() &#123; for (int i = 0; i &lt; filelist.size(); i++) &#123; if (i % 10 == fileIndex) &#123; //读取文件 File readfile = new File(filepath + filelist.get(i)); InputStreamReader isr = null; try &#123; isr = new InputStreamReader(new FileInputStream(readfile), \"UTF-8\"); BufferedReader reader = new BufferedReader(isr); String line = null; // 一次读入一行，直到读入null为文件结束 while ((line = reader.readLine()) != null) &#123; System.out.println(line ); &#125; reader.close(); isr.close(); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; //读取完后， 移动文件位置 readfile.renameTo(new File(movepath + readfile.getName())); &#125; &#125; countDownLatch.countDown(); &#125;&#125;","text":"工具类代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import java.io.*;import java.util.List;import java.util.concurrent.CountDownLatch;/** * 多线程读取多个文件 */public class FileThread extends Thread&#123; private final CountDownLatch countDownLatch = new CountDownLatch(10); private int fileIndex; private List&lt;String&gt; filelist; private String filepath = \"D:\\\\LocalFtpServer\\\\data20181229\\\\\"; private String movepath = \"D:\\\\LocalFtpServer\\\\data20181229_01\\\\\"; public int getFileIndex() &#123; return fileIndex; &#125; public void setFileIndex(int fileIndex) &#123; this.fileIndex = fileIndex; &#125; public List&lt;String&gt; getFilelist() &#123; return filelist; &#125; public void setFilelist(List&lt;String&gt; filelist) &#123; this.filelist = filelist; &#125; @Override public void run() &#123; for (int i = 0; i &lt; filelist.size(); i++) &#123; if (i % 10 == fileIndex) &#123; //读取文件 File readfile = new File(filepath + filelist.get(i)); InputStreamReader isr = null; try &#123; isr = new InputStreamReader(new FileInputStream(readfile), \"UTF-8\"); BufferedReader reader = new BufferedReader(isr); String line = null; // 一次读入一行，直到读入null为文件结束 while ((line = reader.readLine()) != null) &#123; System.out.println(line ); &#125; reader.close(); isr.close(); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; //读取完后， 移动文件位置 readfile.renameTo(new File(movepath + readfile.getName())); &#125; &#125; countDownLatch.countDown(); &#125;&#125; 调用测试： 1234567891011121314151617181920 public static void main(String[] args) throws IOException &#123; String filepath = \"D:\\\\LocalFtpServer\\\\data20181229\\\\\"; File file = new File(filepath); //读取目录下所有文件 String[] filelist = file.list(); List&lt;String&gt; fList=new ArrayList&lt;String&gt;(); for (int i = 0; i &lt; filelist.length; i++) &#123; if (filelist[i].startsWith(\"data\") &amp;&amp; filelist[i].endsWith(\".txt\")) &#123; fList.add(filelist[i]); &#125; &#125; for(int i=0;i&lt;30;i++)&#123; FileThread fileThread=new FileThread(); fileThread.setFileIndex(i); fileThread.setFilelist(fList); fileThread.start(); &#125; countDownLatch.await();&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://yanhq.top/categories/Java/"}],"tags":[{"name":"-Java多线程","slug":"Java多线程","permalink":"http://yanhq.top/tags/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"http://yanhq.top/categories/Java/"}]},{"title":"分布式文件系统HDFS","slug":"Hadoop-HDFS","date":"2019-11-01T15:45:54.077Z","updated":"2019-11-12T09:17:08.372Z","comments":true,"path":"2019/11/01/Hadoop-HDFS/","link":"","permalink":"http://yanhq.top/2019/11/01/Hadoop-HDFS/","excerpt":"Hadoop分布式文件系统——HDFS一、介绍HDFS （Hadoop Distributed File System）是 Hadoop 下的分布式文件系统，具有高容错、高吞吐量等特性，可以部署在低成本的硬件上。","text":"Hadoop分布式文件系统——HDFS一、介绍HDFS （Hadoop Distributed File System）是 Hadoop 下的分布式文件系统，具有高容错、高吞吐量等特性，可以部署在低成本的硬件上。 二、HDFS 设计原理 2.1 HDFS 架构HDFS 遵循主/从架构，由单个 NameNode(NN) 和多个 DataNode(DN) 组成： NameNode : 负责执行有关 文件系统命名空间 的操作，例如打开，关闭、重命名文件和目录等。它同时还负责集群元数据的存储，记录着文件中各个数据块的位置信息。 DataNode：负责提供来自文件系统客户端的读写请求，执行块的创建，删除等操作。 2.2 文件系统命名空间HDFS 的 文件系统命名空间 的层次结构与大多数文件系统类似 (如 Linux)， 支持目录和文件的创建、移动、删除和重命名等操作，支持配置用户和访问权限，但不支持硬链接和软连接。NameNode 负责维护文件系统名称空间，记录对名称空间或其属性的任何更改。 2.3 数据复制由于 Hadoop 被设计运行在廉价的机器上，这意味着硬件是不可靠的，为了保证容错性，HDFS 提供了数据复制机制。HDFS 将每一个文件存储为一系列块，每个块由多个副本来保证容错，块的大小和复制因子可以自行配置（默认情况下，块大小是 128M，默认复制因子是 3）。 2.4 数据复制的实现原理大型的 HDFS 实例在通常分布在多个机架的多台服务器上，不同机架上的两台服务器之间通过交换机进行通讯。在大多数情况下，同一机架中的服务器间的网络带宽大于不同机架中的服务器之间的带宽。因此 HDFS 采用机架感知副本放置策略，对于常见情况，当复制因子为 3 时，HDFS 的放置策略是： 在写入程序位于 datanode 上时，就优先将写入文件的一个副本放置在该 datanode 上，否则放在随机 datanode 上。之后在另一个远程机架上的任意一个节点上放置另一个副本，并在该机架上的另一个节点上放置最后一个副本。此策略可以减少机架间的写入流量，从而提高写入性能。 如果复制因子大于 3，则随机确定第 4 个和之后副本的放置位置，同时保持每个机架的副本数量低于上限，上限值通常为 （复制系数 - 1）/机架数量 + 2，需要注意的是不允许同一个 dataNode 上具有同一个块的多个副本。 2.5 副本的选择为了最大限度地减少带宽消耗和读取延迟，HDFS 在执行读取请求时，优先读取距离读取器最近的副本。如果在与读取器节点相同的机架上存在副本，则优先选择该副本。如果 HDFS 群集跨越多个数据中心，则优先选择本地数据中心上的副本。 2.6 架构的稳定性1. 心跳机制和重新复制每个 DataNode 定期向 NameNode 发送心跳消息，如果超过指定时间没有收到心跳消息，则将 DataNode 标记为死亡。NameNode 不会将任何新的 IO 请求转发给标记为死亡的 DataNode，也不会再使用这些 DataNode 上的数据。 由于数据不再可用，可能会导致某些块的复制因子小于其指定值，NameNode 会跟踪这些块，并在必要的时候进行重新复制。 2. 数据的完整性由于存储设备故障等原因，存储在 DataNode 上的数据块也会发生损坏。为了避免读取到已经损坏的数据而导致错误，HDFS 提供了数据完整性校验机制来保证数据的完整性，具体操作如下： 当客户端创建 HDFS 文件时，它会计算文件的每个块的 校验和，并将 校验和 存储在同一 HDFS 命名空间下的单独的隐藏文件中。当客户端检索文件内容时，它会验证从每个 DataNode 接收的数据是否与存储在关联校验和文件中的 校验和 匹配。如果匹配失败，则证明数据已经损坏，此时客户端会选择从其他 DataNode 获取该块的其他可用副本。 3.元数据的磁盘故障FsImage 和 EditLog 是 HDFS 的核心数据，这些数据的意外丢失可能会导致整个 HDFS 服务不可用。为了避免这个问题，可以配置 NameNode 使其支持 FsImage 和 EditLog 多副本同步，这样 FsImage 或 EditLog 的任何改变都会引起每个副本 FsImage 和 EditLog 的同步更新。 4.支持快照快照支持在特定时刻存储数据副本，在数据意外损坏时，可以通过回滚操作恢复到健康的数据状态。 三、HDFS 的特点3.1 高容错由于 HDFS 采用数据的多副本方案，所以部分硬件的损坏不会导致全部数据的丢失。 3.2 高吞吐量HDFS 设计的重点是支持高吞吐量的数据访问，而不是低延迟的数据访问。 3.3 大文件支持HDFS 适合于大文件的存储，文档的大小应该是是 GB 到 TB 级别的。 3.3 简单一致性模型HDFS 更适合于一次写入多次读取 (write-once-read-many) 的访问模型。支持将内容追加到文件末尾，但不支持数据的随机访问，不能从文件任意位置新增数据。 3.4 跨平台移植性HDFS 具有良好的跨平台移植性，这使得其他大数据计算框架都将其作为数据持久化存储的首选方案。 附：图解HDFS存储原理 说明：以下图片引用自博客：翻译经典 HDFS 原理讲解漫画 1. HDFS写数据原理 2. HDFS读数据原理 3. HDFS故障类型和其检测方法 第二部分：读写故障的处理 第三部分：DataNode 故障处理 副本布局策略： 参考资料 Apache Hadoop 2.9.2 &gt; HDFS Architecture Tom White . hadoop 权威指南 [M] . 清华大学出版社 . 2017. 翻译经典 HDFS 原理讲解漫画","categories":[{"name":"Hadoop","slug":"Hadoop","permalink":"http://yanhq.top/categories/Hadoop/"}],"tags":[{"name":"-HDFS","slug":"HDFS","permalink":"http://yanhq.top/tags/HDFS/"}],"keywords":[{"name":"Hadoop","slug":"Hadoop","permalink":"http://yanhq.top/categories/Hadoop/"}]},{"title":"Hbase常用Shell命令","slug":"Hbase_Shell","date":"2019-11-01T15:45:54.072Z","updated":"2019-11-02T12:05:21.280Z","comments":true,"path":"2019/11/01/Hbase_Shell/","link":"","permalink":"http://yanhq.top/2019/11/01/Hbase_Shell/","excerpt":"Hbase 常用 Shell 命令一、基本命令打开 Hbase Shell：1# hbase shell","text":"Hbase 常用 Shell 命令一、基本命令打开 Hbase Shell：1# hbase shell 1.1 获取帮助1234# 获取帮助help# 获取命令的详细信息help 'status' 1.2 查看服务器状态1status 1.3 查看版本信息1version 二、关于表的操作2.1 查看所有表1list 2.2 创建表 命令格式： create ‘表名称’, ‘列族名称 1’,’列族名称 2’,’列名称 N’ 12# 创建一张名为Student的表,包含基本信息（baseInfo）、学校信息（schoolInfo）两个列族create 'Student','baseInfo','schoolInfo' 2.3 查看表的基本信息 命令格式：desc ‘表名’ 1describe 'Student' 2.4 表的启用/禁用enable 和 disable 可以启用/禁用这个表,is_enabled 和 is_disabled 来检查表是否被禁用 12345678# 禁用表disable 'Student'# 检查表是否被禁用is_disabled 'Student'# 启用表enable 'Student'# 检查表是否被启用is_enabled 'Student' 2.5 检查表是否存在1exists 'Student' 2.6 删除表1234# 删除表前需要先禁用表disable 'Student'# 删除表drop 'Student' 三、增删改3.1 添加列族 命令格式： alter ‘表名’, ‘列族名’ 1alter 'Student', 'teacherInfo' 3.2 删除列族 命令格式：alter ‘表名’, {NAME =&gt; ‘列族名’, METHOD =&gt; ‘delete’} 1alter 'Student', &#123;NAME =&gt; 'teacherInfo', METHOD =&gt; 'delete'&#125; 3.3 更改列族存储版本的限制默认情况下，列族只存储一个版本的数据，如果需要存储多个版本的数据，则需要修改列族的属性。修改后可通过 desc 命令查看。 1alter 'Student',&#123;NAME=&gt;'baseInfo',VERSIONS=&gt;3&#125; 3.4 插入数据 命令格式：put ‘表名’, ‘行键’,’列族:列’,’值’ 注意：如果新增数据的行键值、列族名、列名与原有数据完全相同，则相当于更新操作 12345678910111213141516171819put 'Student', 'rowkey1','baseInfo:name','tom'put 'Student', 'rowkey1','baseInfo:birthday','1990-01-09'put 'Student', 'rowkey1','baseInfo:age','29'put 'Student', 'rowkey1','schoolInfo:name','Havard'put 'Student', 'rowkey1','schoolInfo:localtion','Boston'put 'Student', 'rowkey2','baseInfo:name','jack'put 'Student', 'rowkey2','baseInfo:birthday','1998-08-22'put 'Student', 'rowkey2','baseInfo:age','21'put 'Student', 'rowkey2','schoolInfo:name','yale'put 'Student', 'rowkey2','schoolInfo:localtion','New Haven'put 'Student', 'rowkey3','baseInfo:name','maike'put 'Student', 'rowkey3','baseInfo:birthday','1995-01-22'put 'Student', 'rowkey3','baseInfo:age','24'put 'Student', 'rowkey3','schoolInfo:name','yale'put 'Student', 'rowkey3','schoolInfo:localtion','New Haven'put 'Student', 'wrowkey4','baseInfo:name','maike-jack' 3.5 获取指定行、指定行中的列族、列的信息123456# 获取指定行中所有列的数据信息get 'Student','rowkey3'# 获取指定行中指定列族下所有列的数据信息get 'Student','rowkey3','baseInfo'# 获取指定行中指定列的数据信息get 'Student','rowkey3','baseInfo:name' 3.6 删除指定行、指定行中的列1234# 删除指定行delete 'Student','rowkey3'# 删除指定行中指定列的数据delete 'Student','rowkey3','baseInfo:name' 四、查询hbase 中访问数据有两种基本的方式： 按指定 rowkey 获取数据：get 方法； 按指定条件获取数据：scan 方法。 scan 可以设置 begin 和 end 参数来访问一个范围内所有的数据。get 本质上就是 begin 和 end 相等的一种特殊的 scan。 4.1Get查询123456# 获取指定行中所有列的数据信息get 'Student','rowkey3'# 获取指定行中指定列族下所有列的数据信息get 'Student','rowkey3','baseInfo'# 获取指定行中指定列的数据信息get 'Student','rowkey3','baseInfo:name' 4.2 查询整表数据1scan 'Student' 4.3 查询指定列簇的数据1scan 'Student', &#123;COLUMN=&gt;'baseInfo'&#125; 4.4 条件查询12# 查询指定列的数据scan 'Student', &#123;COLUMNS=&gt; 'baseInfo:birthday'&#125; 除了列 （COLUMNS） 修饰词外，HBase 还支持 Limit（限制查询结果行数），STARTROW（ROWKEY 起始行，会先根据这个 key 定位到 region，再向后扫描）、STOPROW(结束行)、TIMERANGE（限定时间戳范围）、VERSIONS（版本数）、和 FILTER（按条件过滤行）等。 如下代表从 rowkey2 这个 rowkey 开始，查找下两个行的最新 3 个版本的 name 列的数据： 1scan 'Student', &#123;COLUMNS=&gt; 'baseInfo:name',STARTROW =&gt; 'rowkey2',STOPROW =&gt; 'wrowkey4',LIMIT=&gt;2, VERSIONS=&gt;3&#125; 4.5 条件过滤Filter 可以设定一系列条件来进行过滤。如我们要查询值等于 24 的所有数据： 1scan 'Student', FILTER=&gt;\"ValueFilter(=,'binary:24')\" 值包含 yale 的所有数据： 1scan 'Student', FILTER=&gt;\"ValueFilter(=,'substring:yale')\" 列名中的前缀为 birth 的： 1scan 'Student', FILTER=&gt;\"ColumnPrefixFilter('birth')\" FILTER 中支持多个过滤条件通过括号、AND 和 OR 进行组合： 12# 列名中的前缀为birth且列值中包含1998的数据scan 'Student', FILTER=&gt;\"ColumnPrefixFilter('birth') AND ValueFilter ValueFilter(=,'substring:1998')\" PrefixFilter 用于对 Rowkey 的前缀进行判断： 1scan 'Student', FILTER=&gt;\"PrefixFilter('wr')\"","categories":[{"name":"Hbase","slug":"Hbase","permalink":"http://yanhq.top/categories/Hbase/"}],"tags":[{"name":"-Hbase命令","slug":"Hbase命令","permalink":"http://yanhq.top/tags/Hbase%E5%91%BD%E4%BB%A4/"}],"keywords":[{"name":"Hbase","slug":"Hbase","permalink":"http://yanhq.top/categories/Hbase/"}]}]}